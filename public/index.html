// 1. ä¸‹è½½æ ¸å¿ƒå‡½æ•° (ä¿®å¤ï¼šå³ä½¿ä¸çŸ¥é“æ€»å¤§å°ä¹Ÿè¦å›è°ƒ)
async function fetchAndUnzipUgoira(onProgress) {
    if (framesCache) return framesCache;
    
    const zipUrl = getProxyUrl(currentData.original);
    const response = await fetch(zipUrl);
    if (!response.ok) throw new Error(`HTTP Error ${response.status}`);
    
    const contentLength = +response.headers.get('Content-Length'); // å¯èƒ½ä¸º 0 æˆ– NaN
    const reader = response.body.getReader();
    
    let receivedLength = 0; 
    let chunks = [];
    
    while(true) {
        const {done, value} = await reader.read();
        if (done) break;
        chunks.push(value);
        receivedLength += value.length;
        
        // ğŸŸ¢ å…³é”®ä¿®å¤ï¼šæ— è®ºæœ‰æ²¡æœ‰ contentLengthï¼Œéƒ½è°ƒç”¨å›è°ƒ
        // å¦‚æœ contentLength æ˜¯ 0/nullï¼Œä¼ è¿‡å»å°±æ˜¯ 0ï¼Œä»£è¡¨ä¸ç¡®å®šè¿›åº¦
        onProgress(receivedLength, contentLength || 0, 'download');
    }
    
    onProgress(receivedLength, contentLength || receivedLength, 'unzip'); // è¿›å…¥è§£å‹é˜¶æ®µ
    
    const blob = new Blob(chunks);
    const zip = await JSZip.loadAsync(blob);
    const frames = [];
    
    for (let i = 0; i < currentData.frames.length; i++) {
        const f = currentData.frames[i];
        const base64 = await zip.file(f.file).async('base64');
        const img = new Image();
        img.src = "data:image/jpeg;base64," + base64;
        await new Promise(r => img.onload = r);
        frames.push({ img, delay: f.delay });
    }
    framesCache = frames;
    return frames;
}

// 2. æ’­æ”¾å‡½æ•° (é€‚é…æ–°è¿›åº¦æ¡é€»è¾‘)
async function playUgoira() {
    if (!currentData || !currentData.isUgoira) return;
    
    const loader = document.getElementById('loader');
    const fill = document.getElementById('progressFill');
    const txt = document.getElementById('progressText');
    
    loader.classList.add('active');
    
    try {
        const frames = await fetchAndUnzipUgoira((loaded, total, stage) => {
            if(stage === 'download') {
                if(total > 0) {
                    // ğŸŸ¢ çŸ¥é“æ€»å¤§å°ï¼šæ˜¾ç¤ºç™¾åˆ†æ¯”
                    fill.classList.remove('indeterminate');
                    const pct = loaded / total;
                    fill.style.width = `${pct * 100}%`;
                    txt.innerText = `ä¸‹è½½ä¸­ ${Math.round(pct * 100)}%`;
                } else {
                    // ğŸŸ¢ ä¸çŸ¥é“æ€»å¤§å°ï¼šæ˜¾ç¤º MB æ•° + å¾ªç¯åŠ¨ç”»
                    fill.classList.add('indeterminate');
                    fill.style.width = '30%'; // æ ·å¼é‡Œæ§åˆ¶
                    txt.innerText = `ä¸‹è½½ä¸­ ${(loaded / 1024 / 1024).toFixed(1)} MB`;
                }
            } else {
                // è§£ç é˜¶æ®µ
                fill.classList.remove('indeterminate');
                fill.style.width = '100%';
                txt.innerText = 'æ­£åœ¨è§£ç å¸§...';
            }
        });

        const canvas = document.getElementById('ugoiraCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = frames[0].img.width;
        canvas.height = frames[0].img.height;
        
        document.getElementById('ugoiraCover').style.display = 'none';
        document.getElementById('playBtn').style.display = 'none';
        canvas.style.display = 'block';
        loader.classList.remove('active');
        
        let idx = 0;
        function loop() {
            ctx.drawImage(frames[idx].img, 0, 0);
            idx = (idx + 1) % frames.length;
            setTimeout(() => requestAnimationFrame(loop), frames[idx].delay);
        }
        loop();

    } catch (e) {
        console.error(e);
        showToast('æ’­æ”¾å¤±è´¥: ' + e.message);
        loader.classList.remove('active');
    }
}

// 3. GIF è½¬æ¢å‡½æ•° (é€‚é…æ–°è¿›åº¦æ¡é€»è¾‘)
async function convertToGif() {
    if (!currentData.isUgoira) return;
    gifBtn.disabled = true;
    
    const loader = document.getElementById('loader');
    const fill = document.getElementById('progressFill');
    const txt = document.getElementById('progressText');
    
    // å¦‚æœæ’­æ”¾å™¨æ²¡å¼€ï¼Œæˆ‘ä»¬è¦å¼ºåˆ¶æ˜¾ç¤ºé®ç½©å±‚
    const useOverlay = document.getElementById('playBtn').style.display !== 'none';
    if(useOverlay) loader.classList.add('active');
    
    try {
        const frames = await fetchAndUnzipUgoira((loaded, total, stage) => {
            if(useOverlay && stage === 'download') {
                if(total > 0) {
                    fill.classList.remove('indeterminate');
                    fill.style.width = `${(loaded/total)*100}%`;
                    txt.innerText = `ä¸‹è½½ç´ æ ${Math.round((loaded/total)*100)}%`;
                } else {
                    fill.classList.add('indeterminate');
                    txt.innerText = `ä¸‹è½½ç´ æ ${(loaded/1024/1024).toFixed(1)} MB`;
                }
            }
        });
        
        if(useOverlay) {
            fill.classList.remove('indeterminate');
            fill.style.width = '0%';
            txt.innerText = 'åˆå§‹åŒ– GIF å¼•æ“...';
        } else {
            showToast('æ­£åœ¨åå°è½¬æ¢ GIF...');
        }
        
        const workerBlob = await (await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js')).blob();
        const gif = new GIF({
            workers: 2, quality: 10,
            width: frames[0].img.width, height: frames[0].img.height,
            workerScript: URL.createObjectURL(workerBlob)
        });
        
        frames.forEach(f => gif.addFrame(f.img, {delay: f.delay}));
        
        gif.on('progress', p => {
            const percent = Math.round(p * 100);
            if(useOverlay) {
                fill.classList.remove('indeterminate'); // æ¸²æŸ“æ—¶è¿›åº¦æ˜¯ç¡®å®šçš„
                txt.innerText = `æ¸²æŸ“ GIF ${percent}%`;
                fill.style.width = `${percent}%`;
            } else {
                showToast(`GIF æ¸²æŸ“ä¸­ ${percent}%`);
            }
        });
        
        gif.on('finished', blob => {
            if(useOverlay) loader.classList.remove('active');
            saveAs(blob, `Pixiv_GIF_${currentData.title}.gif`);
            showToast('âœ… GIF å¯¼å‡ºæˆåŠŸ');
            gifBtn.disabled = false;
        });
        
        gif.render();
        
    } catch (e) {
        showToast('å¤±è´¥: ' + e.message);
        if(useOverlay) loader.classList.remove('active');
        gifBtn.disabled = false;
    }
}
